name: CI, Guardrails, and CI-aware CHANGELOG

on:
  pull_request:
    branches: ['**']
  push:
    branches: ['**']

permissions:
  contents: write
  pull-requests: write

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: "1"
  DOTNET_NOLOGO: "1"
  EF_PROVIDER: sqlite

jobs:
  changelog-intel:
    name: Changelog (first, batched, low-API)
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build CI-aware CHANGELOG with success emphasis
        uses: actions/github-script@v7
        env:
          MAX_COMMITS: "1500"
          MAX_RUNS: "1500"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function paginate(fn, params, cap=1500) {
              const out = [];
              let page = 1, per_page = params.per_page || 100;
              while (out.length < cap) {
                const res = await fn({ ...params, page, per_page });
                const data = res.data.workflow_runs || res.data.jobs || res.data || [];
                if (!data.length) break;
                out.push(...data);
                if (data.length < per_page) break;
                page++;
              }
              return out.slice(0, cap);
            }

            // 1) Repo commits oldest->newest (capped)
            const commits = [];
            {
              let page = 1, per_page = 100, cap = parseInt(process.env.MAX_COMMITS || "1500", 10);
              while (commits.length < cap) {
                const res = await github.rest.repos.listCommits({ owner, repo, page, per_page });
                if (!res.data.length) break;
                commits.push(...res.data);
                if (res.data.length < per_page) break;
                page++;
              }
              commits.reverse();
            }

            // 2) Workflow runs (batched once) mapped by head_sha
            const runs = await paginate(github.rest.actions.listWorkflowRunsForRepo, {
              owner, repo, per_page: 100
            }, parseInt(process.env.MAX_RUNS || "1500", 10));

            const bySha = new Map();
            for (const r of runs) {
              const key = r.head_sha;
              if (!bySha.has(key) || new Date(r.created_at) > new Date(bySha.get(key).created_at)) {
                bySha.set(key, r);
              }
            }

            // 3) Jobs for mapped runs (paginated per run)
            const jobsByRun = new Map();
            for (const r of bySha.values()) {
              const jobs = await paginate(github.rest.actions.listJobsForWorkflowRun, {
                owner, repo, run_id: r.id, per_page: 100
              }, 400);
              jobsByRun.set(r.id, jobs);
            }

            function classify(msg) {
              const m = (msg || "").trim();
              const re = /^(feat|fix|ci|docs|refactor|test|chore)(\(.+?\))?:/i;
              const hit = re.exec(m);
              return hit ? hit[1].toLowerCase() : "misc";
            }
            function oneline(s){ return (s || "").replace(/\r?\n/g, " ").trim(); }

            let successCount = 0, failureCount = 0, otherCount = 0;

            const lines = [];
            lines.push("# CHANGELOG");
            lines.push("");
            lines.push("_Auto-generated by CI. Commits are annotated with workflow outcomes. ✅ indicates success._");
            lines.push("");

            for (const c of commits) {
              const sha = c.sha;
              const short = sha.substring(0, 7);
              const date = new Date(c.commit.author.date).toISOString().split("T")[0];
              const subject = oneline(c.commit.message.split("\n")[0]);
              const type = classify(subject);

              let outcome = "no runs";
              let jobBreakdown = "";
              const run = bySha.get(sha);

              if (run) {
                outcome = run.conclusion || run.status || "unknown";
                const jobs = jobsByRun.get(run.id) || [];
                const parts = jobs.map(j => `${j.name}:${j.conclusion || j.status}`);
                if (parts.length) jobBreakdown = ` — jobs: ${parts.join(", ")}`;
              }

              let emph = "";
              let subjectRendered = subject;
              if (outcome === "success") {
                successCount++;
                emph = "✅ ";
                subjectRendered = `**${subject}**`;
              } else if (outcome === "failure" || outcome === "cancelled" || outcome === "timed_out") {
                failureCount++;
              } else {
                otherCount++;
              }

              lines.push(`- ${date} \`${short}\` (${type}) — ${emph}${subjectRendered} — CI: ${outcome}${jobBreakdown}`);
            }

            // Insert a summary at the top after header
            const summary = [
              "## CI Outcome Summary",
              `- Success: ${successCount}`,
              `- Failed/Cancelled/Timed out: ${failureCount}`,
              `- Other/No runs: ${otherCount}`,
              ""
            ];
            lines.splice(3, 0, ...summary);

            const content = lines.join("\n") + "\n";

            const path = "docs/CHANGELOG.md";
            let shaExisting;
            try {
              const res = await github.rest.repos.getContent({ 
                owner, repo, path, 
                ref: context.payload.pull_request.head.ref 
              });
              if (!Array.isArray(res.data)) shaExisting = res.data.sha;
            } catch {}
            
            // Write to PR head branch with [skip ci]
            const updateParams = {
              owner, repo, path,
              message: "docs: update CHANGELOG.md [skip ci]",
              content: Buffer.from(content, "utf8").toString("base64"),
              branch: context.payload.pull_request.head.ref
            };
            
            // Only include sha if file exists
            if (shaExisting) {
              updateParams.sha = shaExisting;
            }
            
            await github.rest.repos.createOrUpdateFileContents(updateParams);

  build:
    name: Build & Guardrails
    needs: changelog-intel
    runs-on: macos-latest
    strategy:
      matrix:
        tfm: [net8.0, net8.0-android, net8.0-ios, net8.0-maccatalyst]
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: microsoft
          java-version: "17"

      - name: Install MAUI workload (once)
        run: dotnet workload install maui

      - name: Restore solution (lock files)
        run: dotnet restore ./PhysicallyFitPT.sln --use-lock-file

      - name: Build (matrix)
        run: dotnet build ./PhysicallyFitPT.sln -c Release -f ${{ matrix.tfm }} --nologo

      - name: Assert Web does not reference Infrastructure
        if: matrix.tfm == 'net8.0'
        run: |
          ! grep -q 'PhysicallyFitPT.Infrastructure' ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj || { echo "Web references Infrastructure"; exit 1; }

      - name: Assert NO EF packages in Web
        if: matrix.tfm == 'net8.0'
        run: |
          dotnet list ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj package --include-transitive \
            | grep -Ei 'EntityFrameworkCore|SQLitePCL|Sqlite' && { echo "EF/Sqlite leaked into Web"; exit 1; } || exit 0

      - name: Assert no DbContext usage in Web code
        if: matrix.tfm == 'net8.0'
        run: |
          ! grep -R --include='*.cs' -E 'AddDbContext|UseSqlite|UseInMemoryDatabase' ./PhysicallyFitPT.Web || { echo "DbContext usage found in Web"; exit 1; }

      - name: Assert Sqlite present on devices
        if: matrix.tfm != 'net8.0'
        run: |
          dotnet list ./PhysicallyFitPT/PhysicallyFitPT.csproj package --include-transitive \
            | grep -i 'Microsoft.EntityFrameworkCore.Sqlite'

      - name: Publish (devices)
        if: matrix.tfm != 'net8.0'
        run: dotnet publish ./PhysicallyFitPT/PhysicallyFitPT.csproj -c Release -f ${{ matrix.tfm }} --nologo

      - name: Verify EF design-time uses Sqlite (run once)
        if: matrix.tfm == 'net8.0'
        run: |
          dotnet tool restore || true
          dotnet ef dbcontext info -p ./PhysicallyFitPT.Infrastructure -s ./PhysicallyFitPT/PhysicallyFitPT.csproj

  diff-summary:
    name: Diff Summary
    if: github.event_name == 'pull_request'
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Generate diff summary
        id: diff
        run: |
          base_ref="${{ github.event.pull_request.base.sha || github.event.before }}"
          head_ref="${{ github.sha }}"
          {
            echo "## Change Summary"
            git --no-pager diff --name-status "$base_ref...$head_ref"
            echo -e "\n## High-signal files"
            git --no-pager diff --name-only "$base_ref...$head_ref" | grep -E '\.csproj|props|targets|DesignTimeDbContextFactory|build\.yml|ci\.yml' || true
          } > diff.md
      - uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('diff.md', 'utf8');
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
