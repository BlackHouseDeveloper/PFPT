name: CI, Guardrails, and CI-aware CHANGELOG

on:
  pull_request:
    branches: ['**']
  push:
    branches: ['**']

permissions:
  contents: write
  pull-requests: write

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: "1"
  DOTNET_NOLOGO: "1"
  EF_PROVIDER: sqlite

jobs:
  changelog-intel:
    name: Changelog (first, batched, low-API)
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build CI-aware CHANGELOG with success emphasis
        uses: actions/github-script@v7
        env:
          MAX_COMMITS: "1500"
          MAX_RUNS: "1500"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function paginate(fn, params, cap=1500) {
              const out = [];
              let page = 1, per_page = params.per_page || 100;
              while (out.length < cap) {
                const res = await fn({ ...params, page, per_page });
                const data = res.data.workflow_runs || res.data.jobs || res.data || [];
                if (!data.length) break;
                out.push(...data);
                if (data.length < per_page) break;
                page++;
              }
              return out.slice(0, cap);
            }

            // 1) Repo commits oldest->newest (capped)
            const commits = [];
            {
              let page = 1, per_page = 100, cap = parseInt(process.env.MAX_COMMITS || "1500", 10);
              while (commits.length < cap) {
                const res = await github.rest.repos.listCommits({ owner, repo, page, per_page });
                if (!res.data.length) break;
                commits.push(...res.data);
                if (res.data.length < per_page) break;
                page++;
              }
              commits.reverse();
            }

            // 2) Workflow runs (batched once) mapped by head_sha
            const runs = await paginate(github.rest.actions.listWorkflowRunsForRepo, {
              owner, repo, per_page: 100
            }, parseInt(process.env.MAX_RUNS || "1500", 10));

            const bySha = new Map();
            for (const r of runs) {
              const key = r.head_sha;
              if (!bySha.has(key) || new Date(r.created_at) > new Date(bySha.get(key).created_at)) {
                bySha.set(key, r);
              }
            }

            // 3) Jobs for mapped runs (paginated per run)
            const jobsByRun = new Map();
            for (const r of bySha.values()) {
              const jobs = await paginate(github.rest.actions.listJobsForWorkflowRun, {
                owner, repo, run_id: r.id, per_page: 100
              }, 400);
              jobsByRun.set(r.id, jobs);
            }

            function classify(msg) {
              const m = (msg || "").trim();
              const re = /^(feat|fix|ci|docs|refactor|test|chore)(\(.+?\))?:/i;
              const hit = re.exec(m);
              return hit ? hit[1].toLowerCase() : "misc";
            }
            function oneline(s){ return (s || "").replace(/\r?\n/g, " ").trim(); }

            let successCount = 0, failureCount = 0, otherCount = 0;

            const lines = [];
            lines.push("# CHANGELOG");
            lines.push("");
            lines.push("_Auto-generated by CI. Commits are annotated with workflow outcomes. âœ… indicates success._");
            lines.push("");

            for (const c of commits) {
              const sha = c.sha;
              const short = sha.substring(0, 7);
              const date = new Date(c.commit.author.date).toISOString().split("T")[0];
              const subject = oneline(c.commit.message.split("\n")[0]);
              const type = classify(subject);

              let outcome = "no runs";
              let jobBreakdown = "";
              const run = bySha.get(sha);

              if (run) {
                outcome = run.conclusion || run.status || "unknown";
                const jobs = jobsByRun.get(run.id) || [];
                const parts = jobs.map(j => `${j.name}:${j.conclusion || j.status}`);
                if (parts.length) jobBreakdown = ` â€” jobs: ${parts.join(", ")}`;
              }

              let emph = "";
              let subjectRendered = subject;
              if (outcome === "success") {
                successCount++;
                emph = "âœ… ";
                subjectRendered = `**${subject}**`;
              } else if (outcome === "failure" || outcome === "cancelled" || outcome === "timed_out") {
                failureCount++;
              } else {
                otherCount++;
              }

              lines.push(`- ${date} \`${short}\` (${type}) â€” ${emph}${subjectRendered} â€” CI: ${outcome}${jobBreakdown}`);
            }

            // Insert a summary at the top after header
            const summary = [
              "## CI Outcome Summary",
              `- Success: ${successCount}`,
              `- Failed/Cancelled/Timed out: ${failureCount}`,
              `- Other/No runs: ${otherCount}`,
              ""
            ];
            lines.splice(3, 0, ...summary);

            const content = lines.join("\n") + "\n";

            const path = "docs/CHANGELOG.md";
            
            // Retry logic for file updates with exponential backoff
            let maxRetries = 3;
            let retryDelay = 1000; // Start with 1 second
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
              try {
                // Get the latest file SHA
                let shaExisting;
                try {
                  const res = await github.rest.repos.getContent({ 
                    owner, repo, path, 
                    ref: context.payload.pull_request.head.ref 
                  });
                  if (!Array.isArray(res.data)) shaExisting = res.data.sha;
                } catch {}
                
                // Write to PR head branch with [skip ci]
                const updateParams = {
                  owner, repo, path,
                  message: "docs: update CHANGELOG.md [skip ci]",
                  content: Buffer.from(content, "utf8").toString("base64"),
                  branch: context.payload.pull_request.head.ref
                };
                
                // Only include sha if file exists
                if (shaExisting) {
                  updateParams.sha = shaExisting;
                }
                
                await github.rest.repos.createOrUpdateFileContents(updateParams);
                console.log(`Successfully updated CHANGELOG.md on attempt ${attempt}`);
                break; // Success, exit retry loop
                
              } catch (error) {
                console.log(`Attempt ${attempt} failed: ${error.message}`);
                
                if (attempt === maxRetries) {
                  console.log(`All ${maxRetries} attempts failed. Last error: ${error.message}`);
                  // Don't throw the error - just log it and continue
                  // The CI should not fail just because changelog update failed
                  break;
                }
                
                if (error.status === 409) {
                  console.log(`SHA conflict detected, retrying in ${retryDelay}ms...`);
                  await new Promise(resolve => setTimeout(resolve, retryDelay));
                  retryDelay *= 2; // Exponential backoff
                } else {
                  // For other errors, don't retry
                  console.log(`Non-retryable error: ${error.message}`);
                  break;
                }
              }
            }

  format-check:
    name: StyleCop Formatting
    needs: changelog-intel
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'

      - name: Restore non-mobile projects only (excluding Infrastructure)
        run: |
          dotnet restore ./PhysicallyFitPT.Domain/PhysicallyFitPT.Domain.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Tests/PhysicallyFitPT.Tests.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj --use-lock-file

      - name: Check code formatting (StyleCop) - Infrastructure formatted on macOS
        run: |
          dotnet format ./PhysicallyFitPT.Domain/PhysicallyFitPT.Domain.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./PhysicallyFitPT.Tests/PhysicallyFitPT.Tests.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj --verify-no-changes --verbosity diagnostic

  analyze:
    name: Roslynator Static Analysis
    needs: format-check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'

      - name: Install Roslynator
        run: dotnet tool install -g roslynator.dotnet.cli

      - name: Restore non-mobile projects only (excluding Infrastructure)
        run: |
          dotnet restore ./PhysicallyFitPT.Domain/PhysicallyFitPT.Domain.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Tests/PhysicallyFitPT.Tests.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj --use-lock-file

      - name: Run Roslynator analysis on non-mobile projects (Infrastructure analyzed on macOS)
        run: |
          roslynator analyze ./PhysicallyFitPT.Domain/PhysicallyFitPT.Domain.csproj --severity-level info
          roslynator analyze ./PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj --severity-level info
          roslynator analyze ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj --severity-level info
          roslynator analyze ./PhysicallyFitPT.Tests/PhysicallyFitPT.Tests.csproj --severity-level info
          roslynator analyze ./PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj --severity-level info

  build:
    name: Build & Guardrails
    needs: analyze
    runs-on: macos-latest
    strategy:
      matrix:
        tfm: [net8.0, net8.0-android, net8.0-ios, net8.0-maccatalyst]
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: microsoft
          java-version: "17"

      - name: Install MAUI workload (once)
        run: |
          echo "Installing MAUI workloads..."
          # First, update workload manifests
          dotnet workload update --skip-sign-check || echo "Workload update failed, continuing..."
          
          # Install MAUI workload with multiple fallback strategies
          if ! dotnet workload install maui --skip-sign-check; then
            echo "Standard MAUI workload installation failed, trying individual components..."
            
            # Try installing individual Android/iOS/macCatalyst workloads
            dotnet workload install android --skip-sign-check || echo "Android workload failed"
            dotnet workload install ios --skip-sign-check || echo "iOS workload failed" 
            dotnet workload install maccatalyst --skip-sign-check || echo "macCatalyst workload failed"
            
            # Verify we have at least some workloads installed
            if ! dotnet workload list | grep -q -E "(android|ios|maccatalyst)"; then
              echo "âŒ No mobile workloads installed. This may cause build failures."
              echo "Available workloads:"
              dotnet workload search
              exit 1
            fi
          fi
          
          echo "âœ… Successfully installed workloads:"
          dotnet workload list

      - name: Restore solution (lock files)
        run: |
          echo "Restoring solution with lock files..."
          # Remove any stale lock files that might have cached WebAssembly dependencies
          find . -name "packages.lock.json" -path "*/PhysicallyFitPT/*" -delete || true
          
          # Restore solution and regenerate lock files
          dotnet restore ./PhysicallyFitPT.sln --use-lock-file

      - name: Build net8.0 projects (Web, Infrastructure, etc.)
        if: matrix.tfm == 'net8.0'
        run: |
          dotnet build ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj -c Release -f net8.0 --nologo
          dotnet build ./PhysicallyFitPT.Infrastructure/PhysicallyFitPT.Infrastructure.csproj -c Release -f net8.0 --nologo
          dotnet build ./PhysicallyFitPT.Domain/PhysicallyFitPT.Domain.csproj -c Release -f net8.0 --nologo
          dotnet build ./PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj -c Release -f net8.0 --nologo
          dotnet build ./PhysicallyFitPT.Tests/PhysicallyFitPT.Tests.csproj -c Release -f net8.0 --nologo
          dotnet build ./PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj -c Release -f net8.0 --nologo

      - name: Build mobile app (MAUI)
        if: matrix.tfm != 'net8.0'
        run: |
          echo "Building MAUI app for target framework: ${{ matrix.tfm }}"
          echo "Checking for any remaining WebAssembly dependencies..."
          if grep -r "wasm\|wasi" PhysicallyFitPT/ --include="*.csproj" --include="*.json"; then
            echo "âš ï¸  Found WebAssembly references in MAUI project"
          else
            echo "âœ… No WebAssembly references found in MAUI project"
          fi
          
          # Build the MAUI project for the specific target framework
          dotnet build ./PhysicallyFitPT/PhysicallyFitPT.csproj -c Release -f ${{ matrix.tfm }} --nologo

      - name: Check MAUI project formatting (macOS only)
        if: matrix.tfm == 'net8.0-ios'
        run: dotnet format ./PhysicallyFitPT/PhysicallyFitPT.csproj --verify-no-changes --verbosity diagnostic

      - name: Check Infrastructure project formatting (macOS only)
        if: matrix.tfm == 'net8.0-ios'
        run: dotnet format ./PhysicallyFitPT.Infrastructure/PhysicallyFitPT.Infrastructure.csproj --verify-no-changes --verbosity diagnostic

      - name: Install Roslynator for MAUI analysis (macOS only)
        if: matrix.tfm == 'net8.0-ios'
        run: dotnet tool install -g roslynator.dotnet.cli

      - name: Run Roslynator analysis on MAUI project (macOS only)
        if: matrix.tfm == 'net8.0-ios'
        run: roslynator analyze ./PhysicallyFitPT/PhysicallyFitPT.csproj --severity-level info

      - name: Run Roslynator analysis on Infrastructure project (macOS only)
        if: matrix.tfm == 'net8.0-ios'
        run: roslynator analyze ./PhysicallyFitPT.Infrastructure/PhysicallyFitPT.Infrastructure.csproj --severity-level warning

      - name: Assert Web does not reference Infrastructure
        if: matrix.tfm == 'net8.0'
        run: |
          ! grep -q 'PhysicallyFitPT.Infrastructure' ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj || { echo "Web references Infrastructure"; exit 1; }

      - name: Assert NO EF packages in Web
        if: matrix.tfm == 'net8.0'
        run: |
          dotnet list ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj package --include-transitive \
            | grep -Ei 'EntityFrameworkCore|SQLitePCL|Sqlite' && { echo "EF/Sqlite leaked into Web"; exit 1; } || exit 0

      - name: Assert no DbContext usage in Web code
        if: matrix.tfm == 'net8.0'
        run: |
          ! grep -R --include='*.cs' -E 'AddDbContext|UseSqlite|UseInMemoryDatabase' ./PhysicallyFitPT.Web || { echo "DbContext usage found in Web"; exit 1; }

      - name: Assert Sqlite present on devices
        if: matrix.tfm != 'net8.0'
        run: |
          dotnet list ./PhysicallyFitPT/PhysicallyFitPT.csproj package --include-transitive \
            | grep -i 'Microsoft.EntityFrameworkCore.Sqlite'

      - name: Publish (devices)
        if: matrix.tfm != 'net8.0'
        run: dotnet publish ./PhysicallyFitPT/PhysicallyFitPT.csproj -c Release -f ${{ matrix.tfm }} --nologo

      - name: Verify EF design-time uses Sqlite (run once)
        if: matrix.tfm == 'net8.0'
        run: |
          dotnet tool restore || true
          dotnet ef dbcontext info -p ./PhysicallyFitPT.Infrastructure

      - name: Upload build logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ matrix.tfm }}
          path: |
            **/*.log
            **/*.binlog
          retention-days: 7

  test:
    name: Unit Tests
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'

      - name: Restore non-mobile projects only
        run: |
          dotnet restore ./PhysicallyFitPT.Domain/PhysicallyFitPT.Domain.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Infrastructure/PhysicallyFitPT.Infrastructure.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Tests/PhysicallyFitPT.Tests.csproj --use-lock-file
          dotnet restore ./PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj --use-lock-file

      - name: Run unit tests
        run: dotnet test ./PhysicallyFitPT.Tests/PhysicallyFitPT.Tests.csproj -c Release --logger trx --results-directory TestResults

      - name: Upload test results on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: TestResults/
          retention-days: 7

  notify-failure:
    name: Notify on Failure
    if: failure() && github.event_name == 'pull_request'
    needs: [format-check, analyze, build, test]
    runs-on: ubuntu-latest
    steps:
      - name: Get failed jobs and notify
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const runId = context.runId;
            
            // Get workflow run jobs
            const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
              owner,
              repo,
              run_id: runId,
            });
            
            const failedJobs = jobsResponse.data.jobs.filter(job => 
              job.conclusion === 'failure' || job.conclusion === 'cancelled'
            );
            
            if (failedJobs.length === 0) return;
            
            // Get mentions/reviewers from repository variables
            let mentions = '';
            let reviewers = '';
            
            try {
              const mentionsVar = await github.rest.actions.getRepoVariable({
                owner,
                repo,
                name: 'MENTIONS'
              });
              mentions = mentionsVar.data.value;
            } catch {
              mentions = '@BlackHouseDeveloper @copilot';
            }
            
            try {
              const reviewersVar = await github.rest.actions.getRepoVariable({
                owner,
                repo,
                name: 'REVIEWERS'
              });
              reviewers = reviewersVar.data.value;
            } catch {
              reviewers = 'BlackHouseDeveloper';
            }
            
            // Build failure summary with log tails
            const failureSummary = [];
            failureSummary.push(`${mentions} - CI checks failed! ðŸš«`);
            failureSummary.push('');
            failureSummary.push('## Failed Jobs:');
            
            for (const job of failedJobs) {
              failureSummary.push(`- **${job.name}**: ${job.conclusion}`);
              
              // Get job logs for tail
              try {
                const logsResponse = await github.rest.actions.downloadJobLogsForWorkflowRun({
                  owner,
                  repo,
                  job_id: job.id,
                });
                
                if (logsResponse.data) {
                  const logText = logsResponse.data.toString();
                  const lastLines = logText.split('\n').slice(-50).join('\n');
                  const truncated = lastLines.length > 1000 ? 
                    '...' + lastLines.slice(-1000) : lastLines;
                  
                  failureSummary.push('```');
                  failureSummary.push(truncated);
                  failureSummary.push('```');
                }
              } catch (error) {
                failureSummary.push(`  - Could not fetch logs: ${error.message}`);
              }
            }
            
            failureSummary.push('');
            failureSummary.push('## Action Required:');
            failureSummary.push('- Fix the failed checks before requesting review');
            failureSummary.push('- All gates must pass: format-check â†’ analyze â†’ build â†’ test');
            failureSummary.push(`- Full logs: https://github.com/${owner}/${repo}/actions/runs/${runId}`);
            
            // Post the comment
            const comment = await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: context.issue.number,
              body: failureSummary.join('\n')
            });
            
            // Add reaction to acknowledge the failure notification
            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: comment.data.id,
                content: 'eyes'
              });
            } catch (error) {
              console.log('Could not add reaction:', error.message);
            }
            
            // Automatically trigger Copilot workflow
            try {
              // Use repository_dispatch to trigger Copilot automation
              await github.rest.repos.createDispatchEvent({
                owner,
                repo,
                event_type: 'copilot-auto-fix',
                client_payload: {
                  pr_number: context.issue.number,
                  run_id: runId,
                  failed_jobs: failedJobs.map(job => ({
                    name: job.name,
                    conclusion: job.conclusion,
                    html_url: job.html_url
                  })),
                  trigger_reason: 'automatic_ci_failure'
                }
              });
              
              console.log('Successfully triggered Copilot auto-fix workflow');
            } catch (error) {
              console.log('Could not trigger Copilot auto-fix:', error.message);
              
              // Fallback: Post additional comment to trigger Copilot mention workflow
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.issue.number,
                  body: `ðŸ¤– **Auto-triggering Copilot for CI failure resolution**\n\n@copilot Please analyze and fix the CI failures listed above. Focus on:\n\n${failedJobs.map(job => `- **${job.name}**: ${job.conclusion}`).join('\n')}\n\n*This is an automated request triggered by CI failure.*`
                });
              } catch (fallbackError) {
                console.log('Fallback comment also failed:', fallbackError.message);
              }
            }

  request-review:
    name: Auto-Request Review
    if: success() && github.event_name == 'pull_request'
    needs: [format-check, analyze, build, test]
    runs-on: ubuntu-latest
    steps:
      - name: Request reviewers on success
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Get reviewers from repository variables
            let reviewers = '';
            
            try {
              const reviewersVar = await github.rest.actions.getRepoVariable({
                owner,
                repo,
                name: 'REVIEWERS'
              });
              reviewers = reviewersVar.data.value;
            } catch {
              reviewers = 'BlackHouseDeveloper';
            }
            
            // Parse reviewers (comma/space/newline separated)
            const reviewerList = reviewers
              .split(/[,\s\n]+/)
              .map(r => r.trim())
              .filter(r => r.length > 0);
            
            if (reviewerList.length > 0) {
              try {
                await github.rest.pulls.requestReviewers({
                  owner,
                  repo,
                  pull_number: context.issue.number,
                  reviewers: reviewerList
                });
                
                // Also post a success comment
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.issue.number,
                  body: `âœ… All CI checks passed! Review requested from: ${reviewerList.map(r => '@' + r).join(', ')}`
                });
              } catch (error) {
                console.log('Could not request reviewers:', error.message);
              }
            }

  diff-summary:
    name: Diff Summary
    if: github.event_name == 'pull_request'
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Generate diff summary
        id: diff
        run: |
          base_ref="${{ github.event.pull_request.base.sha || github.event.before }}"
          head_ref="${{ github.sha }}"
          {
            echo "## Change Summary"
            git --no-pager diff --name-status "$base_ref...$head_ref"
            echo -e "\n## High-signal files"
            git --no-pager diff --name-only "$base_ref...$head_ref" | grep -E '\.csproj|props|targets|DesignTimeDbContextFactory|build\.yml|ci\.yml' || true
          } > diff.md
      - uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('diff.md', 'utf8');
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
