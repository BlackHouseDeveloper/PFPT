name: CI, Guardrails, and CI-aware CHANGELOG

on:
  pull_request:
    branches: [main, development]
  push:
    branches: [main, development]

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: "1"
  DOTNET_NOLOGO: "1"
  EF_PROVIDER: sqlite

jobs:
  changelog-post-merge:
    name: Post-Merge Changelog Generation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    concurrency:
      group: changelog-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate post-merge CHANGELOG with success emphasis
        id: generate
        uses: actions/github-script@v7
        env:
          MAX_COMMITS: "500"
          MAX_RUNS: "500"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function paginate(fn, params, cap=1500) {
              const out = [];
              let page = 1, per_page = params.per_page || 100;
              while (out.length < cap) {
                const res = await fn({ ...params, page, per_page });
                const data = res.data.workflow_runs || res.data.jobs || res.data || [];
                if (!data.length) break;
                out.push(...data);
                if (data.length < per_page) break;
                page++;
              }
              return out.slice(0, cap);
            }

            // Get recent commits from main branch
            const commits = [];
            {
              let page = 1, per_page = 100, cap = parseInt(process.env.MAX_COMMITS || "500", 10);
              console.log('Fetching recent commits from main branch...');
              while (commits.length < cap) {
                const res = await github.rest.repos.listCommits({ 
                  owner, repo, 
                  sha: 'main',
                  page, 
                  per_page 
                });
                if (!res.data.length) break;
                commits.push(...res.data);
                if (res.data.length < per_page) break;
                page++;
              }
              commits.reverse(); // Show oldest to newest
              console.log(`Found ${commits.length} commits from main branch`);
            }

            // 2) Workflow runs (batched, reduced scope) mapped by head_sha
            const runs = await paginate(github.rest.actions.listWorkflowRunsForRepo, {
              owner, repo, per_page: 100
            }, parseInt(process.env.MAX_RUNS || "500", 10));

            const bySha = new Map();
            for (const r of runs) {
              const key = r.head_sha;
              if (!bySha.has(key) || new Date(r.created_at) > new Date(bySha.get(key).created_at)) {
                bySha.set(key, r);
              }
            }

            // 3) Jobs for mapped runs (paginated per run, reduced per-run limit)
            const jobsByRun = new Map();
            for (const r of bySha.values()) {
              const jobs = await paginate(github.rest.actions.listJobsForWorkflowRun, {
                owner, repo, run_id: r.id, per_page: 100
              }, 200); // Reduced from 400 to 200 jobs per run
              jobsByRun.set(r.id, jobs);
            }

            function classify(msg) {
              const m = (msg || "").trim();
              const re = /^(feat|fix|ci|docs|refactor|test|chore)(\(.+?\))?:/i;
              const hit = re.exec(m);
              return hit ? hit[1].toLowerCase() : "misc";
            }
            function oneline(s){ return (s || "").replace(/\r?\n/g, " ").trim(); }

            let successCount = 0, failureCount = 0, otherCount = 0;

            const lines = [];
            lines.push("# CHANGELOG");
            lines.push("");
            lines.push("_Auto-generated post-merge by CI. Commits are annotated with workflow outcomes. ‚úÖ indicates success._");
            lines.push("");

            for (const c of commits) {
              const sha = c.sha;
              const short = sha.substring(0, 7);
              const date = new Date(c.commit.author.date).toISOString().split("T")[0];
              const subject = oneline(c.commit.message.split("\n")[0]);
              const type = classify(subject);

              let outcome = "no runs";
              let jobBreakdown = "";
              const run = bySha.get(sha);

              if (run) {
                outcome = run.conclusion || run.status || "unknown";
                const jobs = jobsByRun.get(run.id) || [];
                const parts = jobs.map(j => `${j.name}:${j.conclusion || j.status}`);
                if (parts.length) jobBreakdown = ` ‚Äî jobs: ${parts.join(", ")}`;
              }

              let emph = "";
              let subjectRendered = subject;
              if (outcome === "success") {
                successCount++;
                emph = "‚úÖ ";
                subjectRendered = `**${subject}**`;
              } else if (outcome === "failure" || outcome === "cancelled" || outcome === "timed_out") {
                failureCount++;
              } else {
                otherCount++;
              }

              lines.push(`- ${date} \`${short}\` (${type}) ‚Äî ${emph}${subjectRendered} ‚Äî CI: ${outcome}${jobBreakdown}`);
            }

            // Insert a summary at the top after header
            const summary = [
              "## CI Outcome Summary",
              `- Success: ${successCount}`,
              `- Failed/Cancelled/Timed out: ${failureCount}`,
              `- Other/No runs: ${otherCount}`,
              ""
            ];
            lines.splice(3, 0, ...summary);

            const content = lines.join("\n") + "\n";
            core.setOutput('content', Buffer.from(content, 'utf8').toString('base64'));
            core.setOutput('path', 'docs/CHANGELOG.md');
            return content;

      - name: Update CHANGELOG file
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const path = 'docs/CHANGELOG.md';
            // Decode the content from base64, then re-encode to base64 to avoid double encoding
            const rawContent = Buffer.from('${{ steps.generate.outputs.content }}', 'base64').toString('utf-8');
            const content = Buffer.from(rawContent, 'utf-8').toString('base64');
            
            // Retry logic for file updates with exponential backoff
            let maxRetries = 3;
            let retryDelay = 1000; // Start with 1 second
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
              try {
                // Get the latest file SHA from main branch
                let shaExisting;
                try {
                  const res = await github.rest.repos.getContent({ 
                    owner, repo, path, 
                    ref: 'main'
                  });
                  if (!Array.isArray(res.data)) shaExisting = res.data.sha;
                } catch {}
                
                // Write to main branch with [skip ci]
                const updateParams = {
                  owner, repo, path,
                  message: "docs: update CHANGELOG.md post-merge [skip ci]",
                  content: content,
                  branch: 'main'
                };
                
                // Only include sha if file exists
                if (shaExisting) {
                  updateParams.sha = shaExisting;
                }
                
                await github.rest.repos.createOrUpdateFileContents(updateParams);
                console.log(`Successfully updated CHANGELOG.md on main branch on attempt ${attempt}`);
                break; // Success, exit retry loop
                
              } catch (error) {
                console.log(`Attempt ${attempt} failed: ${error.message}`);
                
                if (attempt === maxRetries) {
                  console.log(`All ${maxRetries} attempts failed. Last error: ${error.message}`);
                  // Don't throw the error - just log it and continue
                  // The CI should not fail just because changelog update failed
                  break;
                }
                
                if (error.status === 409) {
                  console.log(`SHA conflict detected, retrying in ${retryDelay}ms...`);
                  await new Promise(resolve => setTimeout(resolve, retryDelay));
                  retryDelay *= 2; // Exponential backoff
                } else {
                  // For other errors, don't retry
                  console.log(`Non-retryable error: ${error.message}`);
                  break;
                }
              }
            }

  format-check:
    name: StyleCop Formatting
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'
      
      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore Ubuntu-compatible projects only
        run: |
          # Only Domain project can build on Ubuntu without mobile dependencies
          dotnet restore ./src/PhysicallyFitPT.Core/PhysicallyFitPT.Core.csproj --use-lock-file
          echo "Note: Web, Infrastructure, Shared, Tests, and Seeder formatted on macOS due to mobile dependencies"

      - name: Check code formatting (StyleCop) - Ubuntu-compatible project only
        run: |
          # Only format Domain project on Ubuntu
          dotnet format ./src/PhysicallyFitPT.Core/PhysicallyFitPT.Core.csproj --verify-no-changes --verbosity diagnostic

  analyze:
    name: Roslynator Static Analysis
    needs: format-check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'
      
      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Install Roslynator
        run: dotnet tool install -g roslynator.dotnet.cli

      - name: Restore Ubuntu-compatible projects only  
        run: |
          # Only Domain project can build on Ubuntu without mobile dependencies
          dotnet restore ./src/PhysicallyFitPT.Core/PhysicallyFitPT.Core.csproj --use-lock-file
          echo "Note: Web, Infrastructure, Shared, Tests, and Seeder analyzed on macOS due to mobile dependencies"

      - name: Run Roslynator analysis on Ubuntu-compatible project only
        run: |
          # Only analyze Domain project on Ubuntu
          roslynator analyze ./src/PhysicallyFitPT.Core/PhysicallyFitPT.Core.csproj --severity-level info

  build:
    name: Build & Guardrails (${{ matrix.tfm }})
    needs: analyze
    runs-on: ${{ matrix.tfm == 'net8.0' && 'ubuntu-latest' || 'macos-latest' }}
    timeout-minutes: ${{ matrix.tfm == 'net8.0-ios' && 60 || 30 }}
    strategy:
      matrix:
        tfm: [net8.0, net8.0-android, net8.0-ios, net8.0-maccatalyst]
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'
      
      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
      
      - name: Cache MAUI workloads (macOS only)
        if: runner.os == 'macOS'
        uses: actions/cache@v4
        with:
          path: ~/.dotnet/toolResolverCache
          key: ${{ runner.os }}-dotnet-workloads-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-dotnet-workloads-

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: microsoft
          java-version: "17"

      - name: Install MAUI workload (all mobile builds)
        if: matrix.tfm != 'net8.0'
        run: |
          set -e
          echo "Installing MAUI workloads for target: ${{ matrix.tfm }}..."
          
          # Update workload manifests first
          dotnet workload update --skip-sign-check || echo "‚ö†Ô∏è Workload manifest update failed, continuing..."
          
          # Install specific workloads based on target framework with error handling
          case "${{ matrix.tfm }}" in
            "net8.0-android")
              echo "Installing Android workloads..."
              dotnet workload install android --skip-sign-check || echo "‚ùå android workload failed"
              dotnet workload install maui-android --skip-sign-check || echo "‚ùå maui-android workload failed"
              ;;
            "net8.0-ios")
              echo "Installing iOS workloads..."
              dotnet workload install ios --skip-sign-check || echo "‚ùå ios workload failed"
              dotnet workload install maui-ios --skip-sign-check || echo "‚ùå maui-ios workload failed"
              ;;
            "net8.0-maccatalyst")
              echo "Installing macCatalyst workloads..."
              dotnet workload install maccatalyst --skip-sign-check || echo "‚ùå maccatalyst workload failed"
              dotnet workload install maui-maccatalyst --skip-sign-check || echo "‚ùå maui-maccatalyst workload failed"
              ;;
            *)
              echo "Installing all available MAUI workloads..."
              dotnet workload install maui --skip-sign-check || {
                echo "MAUI meta-workload failed, installing individual components..."
                dotnet workload install android --skip-sign-check || echo "android workload not available"
                dotnet workload install ios --skip-sign-check || echo "ios workload not available"
                dotnet workload install maccatalyst --skip-sign-check || echo "maccatalyst workload not available"
                dotnet workload install maui-android --skip-sign-check || echo "maui-android workload not available"
                dotnet workload install maui-ios --skip-sign-check || echo "maui-ios workload not available"
                dotnet workload install maui-maccatalyst --skip-sign-check || echo "maui-maccatalyst workload not available"
              }
              ;;
          esac
          
          echo "‚úÖ Successfully installed workloads:"
          dotnet workload list
           
      - name: Verify MAUI workloads (mobile builds only)
        if: matrix.tfm != 'net8.0'
        run: |
          echo "Verifying MAUI workloads are available..."
          if ! dotnet workload list | grep -q -E "(android|ios|maccatalyst|maui)"; then
            echo "‚ùå No MAUI workloads found. Install failed in previous job."
            echo "Available workloads:"
            dotnet workload search
            exit 1
          else
            echo "‚úÖ MAUI workloads verified:"
            dotnet workload list
          fi
         
      - name: Restore projects (strategy based on matrix.tfm)
        run: |
          if [ "${{ matrix.tfm }}" == "net8.0" ]; then
            echo "Restoring Ubuntu-compatible project (Domain only)..."
            # Only Domain project can build on Ubuntu without mobile dependencies
            dotnet restore ./src/PhysicallyFitPT.Core/PhysicallyFitPT.Core.csproj --use-lock-file
            echo "Note: Web, Infrastructure, Shared, Tests, and Seeder built on macOS due to mobile dependencies"
          else
            echo "Restoring full solution for MAUI builds..."
            dotnet restore ./PFPT.sln --use-lock-file
          fi

      - name: Build net8.0 projects (Ubuntu-compatible only)
        if: matrix.tfm == 'net8.0'
        run: |
          # Build only Domain project that doesn't have mobile dependencies
          echo "Building Ubuntu-compatible net8.0 project..."
          dotnet build ./src/PhysicallyFitPT.Core/PhysicallyFitPT.Core.csproj -c Release -f net8.0 --nologo
          echo "Note: Web, Infrastructure, Shared, Tests, and Seeder built on macOS due to mobile dependencies"

      - name: Build mobile app (MAUI)
        if: matrix.tfm != 'net8.0'
        run: dotnet build ./src/PhysicallyFitPT.Maui/PhysicallyFitPT.Maui.csproj -c Release -f ${{ matrix.tfm }} --nologo

      - name: Build net8.0 projects on macOS (projects with mobile dependencies)
        if: matrix.tfm == 'net8.0-ios'
        run: |
          echo "Building net8.0 projects that have mobile dependencies..."
          dotnet build ./src/PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj -c Release -f net8.0 --nologo
          dotnet build ./src/PhysicallyFitPT.Infrastructure/PhysicallyFitPT.Infrastructure.csproj -c Release -f net8.0 --nologo
          dotnet build ./src/PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj -c Release -f net8.0 --nologo
          dotnet build ./tests/PhysicallyFitPT.Core.Tests/PhysicallyFitPT.Core.Tests.csproj -c Release -f net8.0 --nologo
          dotnet build ./src/PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj -c Release -f net8.0 --nologo

      - name: Install Roslynator for macOS analysis (iOS build only)
        if: matrix.tfm == 'net8.0-ios'
        run: dotnet tool install -g roslynator.dotnet.cli

      - name: Check format for projects with mobile dependencies (macOS only, sequential)
        if: matrix.tfm == 'net8.0-ios'
        run: |
          set -e
          echo "Checking format for projects with mobile dependencies..."
          dotnet format ./src/PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./tests/PhysicallyFitPT.Core.Tests/PhysicallyFitPT.Core.Tests.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./src/PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./src/PhysicallyFitPT.Maui/PhysicallyFitPT.Maui.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./src/PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj --verify-no-changes --verbosity diagnostic
          dotnet format ./src/PhysicallyFitPT.Infrastructure/PhysicallyFitPT.Infrastructure.csproj --verify-no-changes --verbosity diagnostic

      - name: Run Roslynator analysis on projects with mobile dependencies (macOS only, sequential)
        if: matrix.tfm == 'net8.0-ios'
        run: |
          set -e
          echo "Running Roslynator analysis for projects with mobile dependencies..."
          roslynator analyze ./src/PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj --severity-level info
          roslynator analyze ./tests/PhysicallyFitPT.Core.Tests/PhysicallyFitPT.Core.Tests.csproj --severity-level info
          roslynator analyze ./src/PhysicallyFitPT.Seeder/PhysicallyFitPT.Seeder.csproj --severity-level info
          roslynator analyze ./src/PhysicallyFitPT.Maui/PhysicallyFitPT.Maui.csproj --severity-level info
          roslynator analyze ./src/PhysicallyFitPT.Shared/PhysicallyFitPT.Shared.csproj --severity-level info
          roslynator analyze ./src/PhysicallyFitPT.Infrastructure/PhysicallyFitPT.Infrastructure.csproj --severity-level warning

      - name: Assert Web does not reference Infrastructure
        if: matrix.tfm == 'net8.0'
        run: |
          ! grep -q 'PhysicallyFitPT.Infrastructure' ./src/PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj || { echo "‚ùå Web references Infrastructure"; exit 1; }

      - name: Assert NO EF packages in Web
        if: matrix.tfm == 'net8.0'
        run: |
          dotnet list ./src/PhysicallyFitPT.Web/PhysicallyFitPT.Web.csproj package --include-transitive \
            | grep -Ei 'EntityFrameworkCore|SQLitePCL|Sqlite' && { echo "‚ùå EF/Sqlite leaked into Web"; exit 1; } || exit 0

      - name: Assert no DbContext usage in Web code
        if: matrix.tfm == 'net8.0'
        run: |
          ! grep -R --include='*.cs' -E 'AddDbContext|UseSqlite|UseInMemoryDatabase' ./src/PhysicallyFitPT.Web || { echo "‚ùå DbContext usage found in Web"; exit 1; }

      - name: Assert Sqlite present on device TFMs only
        if: matrix.tfm != 'net8.0'
        run: |
          echo "Validating SQLite presence for device target: ${{ matrix.tfm }}"
          if ! dotnet list ./src/PhysicallyFitPT.Maui/PhysicallyFitPT.Maui.csproj package --include-transitive | grep -i 'Microsoft.EntityFrameworkCore.Sqlite'; then
            echo "‚ùå SQLite package not found in device build"
            exit 1
          else
            echo "‚úÖ SQLite package verified for device TFM"
          fi

      - name: Publish (devices)
        if: matrix.tfm != 'net8.0'
        run: dotnet publish ./src/PhysicallyFitPT.Maui/PhysicallyFitPT.Maui.csproj -c Release -f ${{ matrix.tfm }} --nologo

      - name: Verify EF design-time uses Sqlite (run on macOS build only)
        if: matrix.tfm == 'net8.0-ios'
        run: |
          dotnet tool restore || true
          dotnet ef dbcontext info -p ./src/PhysicallyFitPT.Infrastructure

      - name: Upload build logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ matrix.tfm }}
          path: |
            **/*.log
            **/*.binlog
          retention-days: 7

  test:
    name: Unit Tests
    needs: build
    runs-on: macos-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET SDK 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"
          cache: true
          cache-dependency-path: '**/packages.lock.json'
      
      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore test dependencies
        run: |
          dotnet restore ./tests/PhysicallyFitPT.Core.Tests/PhysicallyFitPT.Core.Tests.csproj --use-lock-file

      - name: Run unit tests
        run: |
          echo "Running unit tests..."
          dotnet test ./tests/PhysicallyFitPT.Core.Tests/PhysicallyFitPT.Core.Tests.csproj -c Release --logger trx --results-directory TestResults
          
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: TestResults/
          retention-days: 7

  notify-failure:
    name: Notify on Failure
    if: failure() && github.event_name == 'pull_request'
    needs: [format-check, analyze, build, test]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Get failed jobs and notify
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const runId = context.runId;
            
            // Get workflow run jobs
            const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
              owner,
              repo,
              run_id: runId,
            });
            
            const failedJobs = jobsResponse.data.jobs.filter(job => 
              job.conclusion === 'failure' || job.conclusion === 'cancelled' || job.conclusion === 'timed_out'
            );
            
            if (failedJobs.length === 0) return;
            
            // Get mentions/reviewers from repository variables with better fallbacks
            let mentions = '@BlackHouseDeveloper @copilot';
            let reviewers = 'BlackHouseDeveloper';
            
            try {
              const mentionsVar = await github.rest.actions.getRepoVariable({
                owner,
                repo,
                name: 'MENTIONS'
              });
              if (mentionsVar.data && mentionsVar.data.value && mentionsVar.data.value.trim()) {
                mentions = mentionsVar.data.value.trim();
              }
            } catch (error) {
              console.log('MENTIONS variable not found, using default:', mentions);
            }
            
            try {
              const reviewersVar = await github.rest.actions.getRepoVariable({
                owner,
                repo,
                name: 'REVIEWERS'
              });
              if (reviewersVar.data && reviewersVar.data.value && reviewersVar.data.value.trim()) {
                reviewers = reviewersVar.data.value.trim();
              }
            } catch (error) {
              console.log('REVIEWERS variable not found, using default:', reviewers);
            }
            
            // Build failure summary with log tails
            const failureSummary = [];
            failureSummary.push(`${mentions} - CI checks failed! üö´`);
            failureSummary.push('');
            failureSummary.push('## Failed Jobs:');
            
            for (const job of failedJobs) {
              failureSummary.push(`- **${job.name}**: ${job.conclusion}`);
              
              // Add artifact link for more reliable log access
              failureSummary.push(`  - [View full logs](${job.html_url})`);
              failureSummary.push(`  - [Build artifacts](https://github.com/${owner}/${repo}/actions/runs/${runId})`);
              
              // Get job logs for tail (with better error handling)
              try {
                const logsResponse = await github.rest.actions.downloadJobLogsForWorkflowRun({
                  owner,
                  repo,
                  job_id: job.id,
                });
                
                if (logsResponse.data) {
                  const logText = logsResponse.data.toString();
                  const lastLines = logText.split('\n').slice(-50).join('\n');
                  const truncated = lastLines.length > 1000 ? 
                    '...' + lastLines.slice(-1000) : lastLines;
                  
                  if (truncated.trim()) {
                    failureSummary.push('  <details><summary>üìã Last 50 lines of logs</summary>');
                    failureSummary.push('');
                    failureSummary.push('  ```');
                    failureSummary.push(truncated);
                    failureSummary.push('  ```');
                    failureSummary.push('  </details>');
                  }
                }
              } catch (error) {
                failureSummary.push(`  - ‚ö†Ô∏è Could not fetch logs: ${error.message}`);
                failureSummary.push(`  - Use the links above to access full logs and artifacts`);
              }
            }
            
            failureSummary.push('');
            failureSummary.push('## Action Required:');
            failureSummary.push('- Fix the failed checks before requesting review');
            failureSummary.push('- All gates must pass: format-check ‚Üí analyze ‚Üí build ‚Üí test');
            failureSummary.push(`- Full logs: https://github.com/${owner}/${repo}/actions/runs/${runId}`);
            
            // Post the comment
            const comment = await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: context.issue.number,
              body: failureSummary.join('\n')
            });
            
            // Add reaction to acknowledge the failure notification
            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: comment.data.id,
                content: 'eyes'
              });
            } catch (error) {
              console.log('Could not add reaction:', error.message);
            }
            
            // Automatically trigger Copilot workflow
            try {
              // Use repository_dispatch to trigger Copilot automation
              await github.rest.repos.createDispatchEvent({
                owner,
                repo,
                event_type: 'copilot-auto-fix',
                client_payload: {
                  pr_number: context.issue.number,
                  run_id: runId,
                  failed_jobs: failedJobs.map(job => ({
                    name: job.name,
                    conclusion: job.conclusion,
                    html_url: job.html_url
                  })),
                  trigger_reason: 'automatic_ci_failure'
                }
              });
              
              console.log('Successfully triggered Copilot auto-fix workflow');
            } catch (error) {
              console.log('Could not trigger Copilot auto-fix:', error.message);
              
              // Fallback: Post additional comment to trigger Copilot mention workflow
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.issue.number,
                  body: `ü§ñ **Auto-triggering Copilot for CI failure resolution**\n\n@copilot Please analyze and fix the CI failures listed above. Focus on:\n\n${failedJobs.map(job => `- **${job.name}**: ${job.conclusion}`).join('\n')}\n\n*This is an automated request triggered by CI failure.*`
                });
              } catch (fallbackError) {
                console.log('Fallback comment also failed:', fallbackError.message);
              }
            }

  request-review:
    name: Auto-Request Review
    if: success() && github.event_name == 'pull_request'
    needs: [format-check, analyze, build, test]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Request reviewers on success
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Get reviewers from repository variables with better fallbacks
            let reviewers = 'BlackHouseDeveloper';
            
            try {
              const reviewersVar = await github.rest.actions.getRepoVariable({
                owner,
                repo,
                name: 'REVIEWERS'
              });
              if (reviewersVar.data && reviewersVar.data.value && reviewersVar.data.value.trim()) {
                reviewers = reviewersVar.data.value.trim();
              }
            } catch (error) {
              console.log('REVIEWERS variable not found, using default:', reviewers);
            }
            
            // Parse reviewers (comma/space/newline separated)
            const reviewerList = reviewers
              .split(/[,\s\n]+/)
              .map(r => r.trim())
              .filter(r => r.length > 0);
            
            if (reviewerList.length > 0) {
              try {
                await github.rest.pulls.requestReviewers({
                  owner,
                  repo,
                  pull_number: context.issue.number,
                  reviewers: reviewerList
                });
                
                // Also post a success comment
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.issue.number,
                  body: `‚úÖ All CI checks passed! Review requested from: ${reviewerList.map(r => '@' + r).join(', ')}`
                });
              } catch (error) {
                console.log('Could not request reviewers:', error.message);
              }
            }

  diff-summary:
    name: Diff Summary
    if: github.event_name == 'pull_request'
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Generate diff summary
        id: diff
        run: |
          base_ref="${{ github.event.pull_request.base.sha || github.event.before }}"
          head_ref="${{ github.sha }}"
          {
            echo "## Change Summary"
            git --no-pager diff --name-status "$base_ref...$head_ref"
            echo -e "\n## High-signal files"
            git --no-pager diff --name-only "$base_ref...$head_ref" | grep -E '\.csproj|props|targets|DesignTimeDbContextFactory|build\.yml|ci\.yml' || true
          } > diff.md
      - uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('diff.md', 'utf8');
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });

  summary:
    name: CI Summary
    if: always()
    needs: [format-check, analyze, build, test, notify-failure, request-review, diff-summary]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Generate CI Summary
        uses: actions/github-script@v7
        with:
          script: |
            const jobs = [
              { name: 'Format Check', result: '${{ needs.format-check.result }}' },
              { name: 'Analysis', result: '${{ needs.analyze.result }}' },
              { name: 'Build', result: '${{ needs.build.result }}' },
              { name: 'Tests', result: '${{ needs.test.result }}' },
            ];
            
            let summary = '## CI Results Summary\n\n';
            let passCount = 0;
            let failCount = 0;
            
            for (const job of jobs) {
              const emoji = job.result === 'success' ? '‚úÖ' : job.result === 'failure' ? '‚ùå' : job.result === 'skipped' ? '‚è≠Ô∏è' : '‚ö†Ô∏è';
              summary += `- ${emoji} **${job.name}**: ${job.result}\n`;
              
              if (job.result === 'success') passCount++;
              else if (job.result === 'failure') failCount++;
            }
            
            summary += `\n**Overall**: ${failCount === 0 ? '‚úÖ PASS' : '‚ùå FAIL'} (${passCount} passed, ${failCount} failed)\n`;
            
            await core.summary
              .addHeading('CI Workflow Summary')
              .addRaw(summary)
              .write();
